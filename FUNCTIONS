. $GRIMOIRE/libaccount
. $GRIMOIRE/libgcc

#---------------------------------------------------------------------
## @return 0 if glibc was compiled with NPTL
## @return 1 otherwise
##
## Detects if the current glibc includes NPTL support.
##
#---------------------------------------------------------------------
function glibc_is_nptl ()
{
  if /lib/libc.so.6 | grep -q NPTL; then
    return 0
  fi
  if /lib/libc.so.6 | grep -q "Native POSIX Threads Library"; then
    return 0
  fi
  return 1
}

#---------------------------------------------------------------------
# Runs update-desktop-database if it is installed
#---------------------------------------------------------------------
function update_desktop_database ()
{
  if test -x /usr/bin/update-desktop-database; then
    message "${MESSAGE_COLOR}Updating application mime type database.${DEFAULT_COLOR}"
    /usr/bin/update-desktop-database
  fi
}

#---------------------------------------------------------------------
## this function installs the *.desktop, start* files and qingy links
## this function is intended to be used by spells for windowmanagers
#---------------------------------------------------------------------
function install_wmfiles ()
{
  local wm_desktopfile_dir="${INSTALL_ROOT}/usr/share/xsessions"
  local wm_startwm_dir="${INSTALL_ROOT}/usr/bin"

  # install the start* file for the windowmanager if it's not
  # installed already
  if [ -f ${SCRIPT_DIRECTORY}/start${SPELL} ] ; then
    if ! [ -e ${wm_startwm}/start${SPELL} ] ; then
      install  -m  755  ${SCRIPT_DIRECTORY}/start${SPELL}     \
                        ${wm_startwm_dir}
    fi
  fi

  # making sure the destination directory exists
  if ! [ -d  ${wm_desktopfile_dir} ] ; then
      mkdir  ${wm_desktopfile_dir}
  fi                                                        &&

  # install the windowmanagers desktop file
  if [ -f ${SCRIPT_DIRECTORY}/${SPELL}.desktop ] ; then
    if ! [ -e ${wm_desktopfile_dir}/${SPELL}.desktop ]; then
      install  -m  755  ${SCRIPT_DIRECTORY}/${SPELL}.desktop   \
                        ${wm_desktopfile_dir}
    fi
  fi

  if ( spell_ok qingy ); then
    if [ -x ${wm_startwm_dir}/start${SPELL} ] ; then
      if  [  !  -d  ${INSTALL_ROOT}/etc/qingy/xsessions  ];  then
        install  -d  -m  755  ${INSTALL_ROOT}/etc/qingy/xsessions
      fi                                                 &&
      ln -s ${wm_startwm_dir}/start${SPELL}              \
            ${INSTALL_ROOT}/etc/qingy/xsessions/${SPELL}
    fi
  fi
}

#---------------------------------------------------------------------
## Sets the current script to run only one make job
#---------------------------------------------------------------------

function make_single ()
{
  JOBS_PER_HOST=0  &&
     MAKE_NJOBS=1
}

#---------------------------------------------------------------------
## Re-enables the normal Sorcery make (cancels single_make)
#---------------------------------------------------------------------

function make_normal ()
{
  source $COMPILE_CONFIG
}

#---------------------------------------------------------------------
## @param shellname
## @param full path to shell
##
## Adds a shell to /etc/shells and optionally to qingy's sessions
#---------------------------------------------------------------------
function install_shell ()
{
  local qingy_session_dir="${INSTALL_ROOT}/etc/qingy/sessions"

  if [ -z "$1" ] ; then
    message "${PROBLEM_COLOR}no shell name specified, aborting${DEFAULT_COLOR}"
    return 1
  fi &&
  if [ ! -e "$2" ] ; then
    message "${PROBLEM_COLOR} $2 isn't executable, no use adding it as a shell${DEFAULT_COLOR}"
    return 1
  fi &&

  #installing shell into /etc/shells
  message "installing $1 into /etc/shells"
  if ! ( grep -q "${2}" ${INSTALL_ROOT}/etc/shells ) ; then
    echo "$2" >> ${INSTALL_ROOT}/etc/shells
  fi || return 1

  #installing shell into qingy's session dir if it's installed
  if ( spell_ok qingy ) && ! [ -f ${qingy_session_dir}/$1 ] ; then
    message "installing $1 into $qingy_session_dir"
    echo "$2" > ${qingy_session_dir}/$1 &&
    chmod 0755 ${qingy_session_dir}/$1
  fi
}

#---------------------------------------------------------------------
## @param shellname
## @param full path to shell
##
## Removes a shell from /etc/shells and optionally from qingy's sessions
#---------------------------------------------------------------------
function remove_shell ()
{
  local qingy_session_dir="${INSTALL_ROOT}/etc/qingy/sessions"

  if [ -z "$1" ] ; then
    message "${PROBLEM_COLOR}no shell name specified, aborting${DEFAULT_COLOR}"
    return 1
  fi &&
  if [ -z "$2" ] ; then
    message "${PROBLEM_COLOR}no shell path specified, aborting${DEFAULT_COLOR}"
    return 1
  fi &&

  #removing shell from /etc/shells
  if  [  -f  /etc/shells  ]  ;  then
    cat /etc/shells|grep -v "$2" > /etc/shells.tmp &&
    mv /etc/shells.tmp /etc/shells
  fi

  # and optionally from qingy's session dir
  if [ -f ${qingy_session_dir}/$1 ] ; then
    message "removing $1 from $qingy_session_dir"
    rm -f ${qingy_session_dir}/$1
  fi
}


#---------------------------------------------------------------------
## replacement for config_query_string to work around a short timeout
## when entering long strings (hostnames, organisation names)
#---------------------------------------------------------------------
function config_query_long_string() {
    local ANSWER
    local DELAY=5 
    if config_get_option "$1" ANSWER; then
        # option allready answered in config
        echo -e "[[ ${QUERY_COLOR}$2${DEFAULT} -> '${QUERY_COLOR}$ANSWER${DEFAULT}' ]]"
    else
        query_string ANSWER "$2" "$3"
        read -t $DELAY -n 1 ANSWER_first
        if [[ $ANSWER_first ]] ; then 
          read ANSWER_rest
        fi
        ANSWER="${ANSWER_first}${ANSWER_rest}"
        config_set_option "$1" "$ANSWER"
    fi
    return 0
}

#---
## @Synopsis default_games_build function to replace
## @Synopsis all the duplication of the same stuff in games-grimoire
#---

function default_games_build() {
  OPTS="$OPTS --bindir=${INSTALL_ROOT}/usr/games \
  --datadir=${INSTALL_ROOT}/usr/share/games \
  --localstatedir=${INSTALL_ROOT}/var/games"  &&
  default_build
}


#---
## @Synopsis profile_install function to make installing
## @Synopsis of /etc/profile.d/$spell.sh easier...
#---

function profile_install() {
  if [ -f ${SCRIPT_DIRECTORY}/profile/${SPELL}.sh ] ; then
    if ! [ -e ${INSTALL_ROOT}/etc/profile.d/${SPELL}.sh ] ; then
      install  -m  755  ${SCRIPT_DIRECTORY}/profile/${SPELL}.sh \
                        ${INSTALL_ROOT}/etc/profile.d/${SPELL}.sh
    fi
  fi
   
}


#-------------------------------------------------------------------------
## Compatibility code for gracefully failing if the user uses an older
## version of sorcery with a spell that calls unpack_file.
#-------------------------------------------------------------------------
declare -f unpack_file &> /dev/null ||
function unpack_file() {
  message "This spell uses a function only available in sorcery 1.12.2 or newer, please update."
  return 1
}

#---
## @Synopsis A function to find all dirs and files and set them to
## @Synopsis proper permissions.
#---

function find_and_scam() {
  find ./ -type d | xargs chmod 0750
  find ./ -type d | xargs chown root.games
  find ./ -type f | xargs chmod 0640
  find ./ -type f | xargs chown root.games
}

#---
## @Synopsis games_create_base_dirs function to replace
## @Synopsis all the duplication of the same stuff in games-grimoire
## @Synopsis and to provide some basics for all spells
#---

function games_create_base_dirs() {
  mkdir -vp ${INSTALL_ROOT}/usr/share/games/${SPELL}
  mkdir -vp ${INSTALL_ROOT}/usr/games
  mkdir -vp ${INSTALL_ROOT}/var/games
}

#---
## @Synopsis games_make_proper_binary function to make all
## @Synopsis binaries in /usr/games chown root.games and
## @Synopsis chmod 0750.
#---

function games_make_proper_binary() {
  cat $IW_LOG | cut -f 3 | uniq | sort | grep "usr/games/" | xargs chmod 0750
  cat $IW_LOG | cut -f 3 | uniq | sort | grep "usr/games/" | xargs chown root.games
}

#---
## @Synopsis default_post_install function to
## @Synopsis clean out any empty share/games/SPELL dirs
## @Synopsis and run the real_default_post_install afterwards
#---

function default_post_install() {
  games_make_proper_binary &&
  rmdir --ignore-fail-on-non-empty ${INSTALL_ROOT}/usr/share/games/${SPELL} &&
  real_default_post_install
}

#---
## @Synopsis default_pre_install function to
## @Synopsis create some base dirs for spells
## @Synopsis after running real_default_pre_install
#---

function default_pre_install() {
  real_default_pre_install &&
  games_create_base_dirs
}
